/*
 * react-twoo
 * undefined
 * https://github.com/aarondupon/react-twoo
 * v0.1.0
 * undefined License
 */

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _commonjsHelpers = require('../../../../_virtual/_commonjsHelpers.js');
var CanvasRenderer = require('./renderers/canvas/CanvasRenderer.js');
var index = require('./utils/index.js');
var WebGLRenderer = require('./renderers/webgl/WebGLRenderer.js');

var autoDetectRenderer_1 = _commonjsHelpers.createCommonjsModule(function (module, exports) {

exports.__esModule = true;
exports.autoDetectRenderer = autoDetectRenderer;



var utils$1 = _interopRequireWildcard(index.__moduleExports);



var _CanvasRenderer2 = _interopRequireDefault(CanvasRenderer);



var _WebGLRenderer2 = _interopRequireDefault(WebGLRenderer);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};

    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) { newObj[key] = obj[key]; }
      }
    }

    newObj["default"] = obj;
    return newObj;
  }
} // eslint-disable-next-line valid-jsdoc

/**
 * This helper function will automatically detect which renderer you should be using.
 * WebGL is the preferred renderer as it is a lot faster. If webGL is not supported by
 * the browser then this function will return a canvas renderer
 *
 * @memberof PIXI
 * @function autoDetectRenderer
 * @param {object} [options] - The optional renderer parameters
 * @param {number} [options.width=800] - the width of the renderers view
 * @param {number} [options.height=600] - the height of the renderers view
 * @param {HTMLCanvasElement} [options.view] - the canvas to use as a view, optional
 * @param {boolean} [options.transparent=false] - If the render view is transparent, default false
 * @param {boolean} [options.antialias=false] - sets antialias (only applicable in chrome at the moment)
 * @param {boolean} [options.preserveDrawingBuffer=false] - enables drawing buffer preservation, enable this if you
 *      need to call toDataUrl on the webgl context
 * @param {number} [options.resolution=1] - The resolution / device pixel ratio of the renderer, retina would be 2
 * @param {boolean} [options.forceCanvas=false] - prevents selection of WebGL renderer, even if such is present
 * @return {PIXI.WebGLRenderer|PIXI.CanvasRenderer} Returns WebGL renderer if available, otherwise CanvasRenderer
 */


function autoDetectRenderer(options, arg1, arg2, arg3) {
  // Backward-compatible support for noWebGL option
  var forceCanvas = options && options.forceCanvas;

  if (arg3 !== undefined) {
    forceCanvas = arg3;
  }

  if (!forceCanvas && utils$1.isWebGLSupported()) {
    return new _WebGLRenderer2["default"](options, arg1, arg2);
  }

  return new _CanvasRenderer2["default"](options, arg1, arg2);
}
});

_commonjsHelpers.unwrapExports(autoDetectRenderer_1);
var autoDetectRenderer_2 = autoDetectRenderer_1.autoDetectRenderer;

exports.__moduleExports = autoDetectRenderer_1;
exports.autoDetectRenderer = autoDetectRenderer_2;
